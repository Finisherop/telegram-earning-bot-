/**\n * Firebase User Data Sync Fix - Complete Solution\n * \n * This file implements comprehensive fixes for Firebase user data sync issues:\n * 1. Prevents all undefined value writes to Firebase\n * 2. Implements real-time listeners with instant UI updates\n * 3. Wraps Firebase operations in DOMContentLoaded for proper initialization\n * 4. Provides safe user object creation and validation\n */\n\nimport { User } from '@/types';\nimport { ref, set, update, get, onValue, off } from 'firebase/database';\nimport { realtimeDb } from './firebase';\nimport { getTelegramUserSafe, getUserIdForFirebase } from './telegramUserSafe';\nimport { VIP_TIERS } from './constants';\n\n// Global map to track active listeners\nconst activeListeners = new Map<string, () => void>();\n\n/**\n * Creates a completely safe user object with NO undefined values\n * This is the definitive function to prevent Firebase \"undefined\" errors\n */\nexport function createCompletelyFirebaseSafeUser(telegramUser?: any, referralId?: string): User {\n  const now = new Date();\n  const userId = telegramUser ? getUserIdForFirebase(telegramUser) || 'user_default' : 'user_default';\n  \n  // Create user with ALL required fields explicitly defined\n  const safeUser: User = {\n    // Identity fields - NEVER undefined\n    id: userId,\n    telegramId: userId,\n    username: telegramUser?.username || telegramUser?.first_name?.toLowerCase()?.replace(/[^a-z0-9]/g, '') || '',\n    firstName: telegramUser?.first_name || telegramUser?.firstName || 'User',\n    lastName: telegramUser?.last_name || telegramUser?.lastName || '',\n    profilePic: telegramUser?.photo_url || telegramUser?.profilePic || '',\n    \n    // Game data - ALL defined with safe defaults\n    coins: 0,\n    xp: 0,\n    level: 1,\n    \n    // VIP data - ALL defined\n    vipTier: 'free',\n    farmingMultiplier: VIP_TIERS.free.farmingMultiplier || 1,\n    referralMultiplier: VIP_TIERS.free.referralMultiplier || 1,\n    adsLimitPerDay: VIP_TIERS.free.adsLimitPerDay || 5,\n    withdrawalLimit: VIP_TIERS.free.withdrawalLimit || 1000,\n    minWithdrawal: VIP_TIERS.free.minWithdrawal || 100,\n    \n    // Referral data - ALL defined\n    referrerId: referralId || '',\n    referralCount: 0,\n    referralEarnings: 0,\n    \n    // Game state - ALL defined\n    dailyStreak: 0,\n    \n    // Timestamps - ALWAYS defined\n    createdAt: now,\n    updatedAt: now\n  };\n  \n  // Validate: ensure NO undefined values exist\n  Object.keys(safeUser).forEach(key => {\n    if ((safeUser as any)[key] === undefined) {\n      console.error(`[Firebase Safe User] CRITICAL: Found undefined value for key: ${key}`);\n      throw new Error(`Unsafe user object created - undefined value for: ${key}`);\n    }\n  });\n  \n  console.log('[Firebase Safe User] ✅ Created completely safe user object:', {\n    id: safeUser.id,\n    firstName: safeUser.firstName,\n    coins: safeUser.coins,\n    undefinedCheck: 'PASSED'\n  });\n  \n  return safeUser;\n}\n\n/**\n * Sanitizes ANY data before Firebase write - ultimate protection\n */\nexport function ultimateFirebaseSanitizer(data: any): any {\n  if (data === undefined) {\n    console.warn('[Firebase Sanitizer] Received undefined data, returning empty object');\n    return {};\n  }\n  \n  if (data === null || typeof data !== 'object') {\n    return data;\n  }\n  \n  const sanitized: any = {};\n  \n  Object.entries(data).forEach(([key, value]) => {\n    if (value === undefined) {\n      console.warn(`[Firebase Sanitizer] ⚠️ Removing undefined value for key: ${key}`);\n      // NEVER add undefined values to sanitized object\n      return;\n    }\n    \n    if (value === null) {\n      sanitized[key] = null;\n    } else if (value instanceof Date) {\n      sanitized[key] = value.toISOString();\n    } else if (typeof value === 'string') {\n      sanitized[key] = value.trim();\n    } else if (typeof value === 'number' && !isNaN(value)) {\n      sanitized[key] = value;\n    } else if (typeof value === 'boolean') {\n      sanitized[key] = value;\n    } else if (typeof value === 'object' && value !== null) {\n      // Recursively sanitize nested objects\n      const nested = ultimateFirebaseSanitizer(value);\n      if (Object.keys(nested).length > 0) {\n        sanitized[key] = nested;\n      }\n    } else {\n      sanitized[key] = value;\n    }\n  });\n  \n  return sanitized;\n}\n\n/**\n * Safe Firebase user creation/update with comprehensive error prevention\n */\nexport async function safeFirebaseUserSync(userId: string, userData: Partial<User>, isNewUser: boolean = false): Promise<{ success: boolean; error?: string }> {\n  try {\n    if (!realtimeDb) {\n      throw new Error('Firebase Realtime Database not initialized');\n    }\n    \n    console.log(`[Safe Firebase Sync] ${isNewUser ? 'Creating' : 'Updating'} user: ${userId}`);\n    \n    // Ultimate sanitization\n    const sanitizedData = ultimateFirebaseSanitizer(userData);\n    \n    // Final check: ensure no undefined values in serialized data\n    const jsonString = JSON.stringify(sanitizedData);\n    if (jsonString.includes('undefined') || jsonString.includes('\"undefined\"')) {\n      console.error('[Safe Firebase Sync] CRITICAL: Sanitized data contains undefined!', sanitizedData);\n      throw new Error('Data sanitization failed - undefined values detected');\n    }\n    \n    const userRef = ref(realtimeDb, `telegram_users/${userId}`);\n    \n    if (isNewUser) {\n      // For new users, add server timestamp\n      const newUserData = {\n        ...sanitizedData,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      };\n      \n      console.log('[Safe Firebase Sync] Creating new user with keys:', Object.keys(newUserData));\n      await set(userRef, newUserData);\n    } else {\n      // For updates, only update provided fields\n      const updateData = {\n        ...sanitizedData,\n        updatedAt: new Date().toISOString()\n      };\n      \n      console.log('[Safe Firebase Sync] Updating user with keys:', Object.keys(updateData));\n      await update(userRef, updateData);\n    }\n    \n    console.log(`[Safe Firebase Sync] ✅ Successfully ${isNewUser ? 'created' : 'updated'} user: ${userId}`);\n    return { success: true };\n    \n  } catch (error) {\n    console.error(`[Safe Firebase Sync] ❌ Failed to ${isNewUser ? 'create' : 'update'} user ${userId}:`, error);\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown Firebase error'\n    };\n  }\n}\n\n/**\n * Sets up real-time listener with instant UI updates\n */\nexport function setupRealtimeUserListener(\n  userId: string, \n  callback: (user: User | null) => void,\n  onError?: (error: Error) => void\n): () => void {\n  if (!realtimeDb) {\n    console.error('[Realtime Listener] Firebase not initialized');\n    return () => {};\n  }\n  \n  const userRef = ref(realtimeDb, `telegram_users/${userId}`);\n  const listenerId = `user_${userId}_${Date.now()}`;\n  \n  const handleSnapshot = (snapshot: any) => {\n    try {\n      if (snapshot.exists()) {\n        const userData = snapshot.val();\n        \n        // Convert Firebase data back to User object with proper types\n        const user: User = {\n          ...userData,\n          id: userId,\n          telegramId: userId,\n          // Convert ISO strings back to Date objects\n          createdAt: userData.createdAt ? new Date(userData.createdAt) : new Date(),\n          updatedAt: userData.updatedAt ? new Date(userData.updatedAt) : new Date(),\n          lastClaimDate: userData.lastClaimDate ? new Date(userData.lastClaimDate) : undefined,\n          farmingStartTime: userData.farmingStartTime ? new Date(userData.farmingStartTime) : undefined,\n          farmingEndTime: userData.farmingEndTime ? new Date(userData.farmingEndTime) : undefined,\n          vipEndTime: userData.vipEndTime ? new Date(userData.vipEndTime) : undefined\n        };\n        \n        console.log(`[Realtime Listener] 📡 User data received for ${userId}:`, {\n          coins: user.coins,\n          vipTier: user.vipTier,\n          timestamp: new Date().toISOString()\n        });\n        \n        callback(user);\n      } else {\n        console.log(`[Realtime Listener] No data found for user: ${userId}`);\n        callback(null);\n      }\n    } catch (error) {\n      console.error(`[Realtime Listener] Error processing data for ${userId}:`, error);\n      if (onError) onError(error as Error);\n    }\n  };\n  \n  const handleError = (error: Error) => {\n    console.error(`[Realtime Listener] Firebase error for ${userId}:`, error);\n    if (onError) onError(error);\n  };\n  \n  // Set up the listener\n  const unsubscribe = onValue(userRef, handleSnapshot, handleError);\n  \n  // Store cleanup function\n  const cleanup = () => {\n    off(userRef, 'value', handleSnapshot);\n    activeListeners.delete(listenerId);\n    console.log(`[Realtime Listener] Cleaned up listener for user: ${userId}`);\n  };\n  \n  activeListeners.set(listenerId, cleanup);\n  \n  console.log(`[Realtime Listener] 🔄 Started real-time sync for user: ${userId}`);\n  \n  return cleanup;\n}\n\n/**\n * Initialize user with comprehensive safety checks\n * Wraps everything in DOMContentLoaded for proper timing\n */\nexport async function initializeUserSafely(): Promise<{\n  user: User | null;\n  userId: string | null;\n  setupListener: () => void;\n}> {\n  return new Promise((resolve) => {\n    const initialize = async () => {\n      try {\n        console.log('[Safe User Init] Starting safe user initialization...');\n        \n        // Get Telegram user safely\n        const telegramUser = getTelegramUserSafe();\n        const userId = getUserIdForFirebase(telegramUser);\n        \n        if (!userId) {\n          console.error('[Safe User Init] Unable to get valid user ID');\n          resolve({ user: null, userId: null, setupListener: () => {} });\n          return;\n        }\n        \n        console.log(`[Safe User Init] User ID: ${userId}`);\n        \n        // Check if user exists in Firebase\n        let user: User | null = null;\n        \n        try {\n          if (realtimeDb) {\n            const userRef = ref(realtimeDb, `telegram_users/${userId}`);\n            const snapshot = await get(userRef);\n            \n            if (snapshot.exists()) {\n              const userData = snapshot.val();\n              user = {\n                ...userData,\n                id: userId,\n                telegramId: userId,\n                createdAt: userData.createdAt ? new Date(userData.createdAt) : new Date(),\n                updatedAt: userData.updatedAt ? new Date(userData.updatedAt) : new Date(),\n                lastClaimDate: userData.lastClaimDate ? new Date(userData.lastClaimDate) : undefined,\n                farmingStartTime: userData.farmingStartTime ? new Date(userData.farmingStartTime) : undefined,\n                farmingEndTime: userData.farmingEndTime ? new Date(userData.farmingEndTime) : undefined,\n                vipEndTime: userData.vipEndTime ? new Date(userData.vipEndTime) : undefined\n              };\n              console.log('[Safe User Init] ✅ Existing user loaded');\n            } else {\n              // Create new user with safe defaults\n              user = createCompletelyFirebaseSafeUser(telegramUser);\n              const result = await safeFirebaseUserSync(userId, user, true);\n              \n              if (result.success) {\n                console.log('[Safe User Init] ✅ New user created successfully');\n              } else {\n                console.error('[Safe User Init] ❌ Failed to create new user:', result.error);\n              }\n            }\n          }\n        } catch (error) {\n          console.error('[Safe User Init] Error accessing Firebase:', error);\n          // Create offline user as fallback\n          user = createCompletelyFirebaseSafeUser(telegramUser);\n        }\n        \n        // Return user and setup function for listener\n        const setupListener = () => {\n          if (userId) {\n            return setupRealtimeUserListener(userId, (updatedUser) => {\n              console.log('[Safe User Init] Real-time update received');\n              // This would typically update the UI through a callback\n            });\n          }\n          return () => {};\n        };\n        \n        resolve({ user, userId, setupListener });\n        \n      } catch (error) {\n        console.error('[Safe User Init] Initialization failed:', error);\n        resolve({ user: null, userId: null, setupListener: () => {} });\n      }\n    };\n    \n    // Ensure DOM is ready before Firebase operations\n    if (document.readyState === 'complete') {\n      initialize();\n    } else {\n      const handler = () => {\n        if (document.readyState === 'complete') {\n          document.removeEventListener('readystatechange', handler);\n          initialize();\n        }\n      };\n      document.addEventListener('readystatechange', handler);\n      \n      // Fallback timeout\n      setTimeout(initialize, 2000);\n    }\n  });\n}\n\n/**\n * Cleanup all active listeners\n */\nexport function cleanupAllListeners(): void {\n  console.log(`[Firebase Cleanup] Cleaning up ${activeListeners.size} active listeners`);\n  activeListeners.forEach(cleanup => cleanup());\n  activeListeners.clear();\n}\n\n// Export everything needed for the fixes\nexport {\n  createCompletelyFirebaseSafeUser as createSafeUser,\n  ultimateFirebaseSanitizer as sanitizeForFirebase,\n  safeFirebaseUserSync as updateUserSafe,\n  setupRealtimeUserListener as subscribeToUser\n};\n